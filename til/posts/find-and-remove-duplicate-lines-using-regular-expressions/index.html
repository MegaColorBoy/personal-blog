<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Find and remove duplicate lines using Regular Expressions | megacolorboy</title>
	<link rel="stylesheet" href="/static/css/main.css" type="text/css">
	<link rel="stylesheet" href="/static/vendor/hljs/css/default.min.css">
	<!-- Add OG tags  -->
</head>
<body class="details-page til">
	<!-- Navbar -->
	<header class="header">
	<div class="author">
		<a href="/">
			<div class="logo"></div>
			<p>megacolorboy</p>
		</a>
	</div>
	<nav>
		<ul class="menu">
			
				<li><a href="/about">About</a></li>
			
				<li><a href="/writings">Writings</a></li>
			
				<li><a href="/til">Today I Learned</a></li>
			
		</ul>
	</nav>
</header>

<div class="article-top">
	<a class="back" href="/til"><span>&larr;</span> Back</a>
	<p class="date">Published on November 7th, 2020</p>	
</div>

<main>
	<section class="article-head">
		<p class="cat">Regular Expressions</p>
		<h1>Find and remove duplicate lines using Regular Expressions</h1>
		
			<p>Open up your text editor and use the following RegEx pattern to find and remove the duplicate lines:I found this technique on Regular-Expressions.info and I'm going to quote their explanation over here:The caret will match only at the start of a line. So the regex engine will only attempt to match the remainder of the regex there. The dot and star combination simply matches an entire line, whatever its contents, if any. The parentheses store the matched line into the first backreference.Next we will match the line separator. I put the question mark into  to make this regex work with both Windows  and UNIX  text files. So up to this point we matched a line and the following line break.Now we need to check if this combination is followed by a duplicate of that same line. We do this simply with . This is the first backreference which holds the line we matched. The backreference will match that very same text.If the backreference fails to match, the regex match and the backreference are discarded, and the regex engine tries again at the start of the next line. If the backreference succeeds, the plus symbol in the regular expression will try to match additional copies of the line. Finally, the dollar symbol forces the regex engine to check if the text matched by the backreference is a complete line. We already know the text matched by the backreference is preceded by a line break (matched by ).Therefore, we now check if it is also followed by a line break or if it is at the end of the file using the dollar sign.The entire match becomes  (or  etc.). Because we are doing a search and replace, the line, its duplicates, and the line breaks in between them, are all deleted from the file. Since we want to keep the original line, but not the duplicates, we use  as the replacement text to put the original line back in.Hope you found this tip useful!</p>
		
		<p class="date">2 minutes read</p>
	</section>
	<article>
		<p>Open up your text editor and use the following RegEx pattern to find and remove the duplicate lines:</p>

<pre>
<code>
^(.*)(\r?\n\1)+$
</code>
</pre>

<p>I found this technique on <a href="http://www.regular-expressions.info/duplicatelines.html">Regular-Expressions.info</a> and I'm going to quote their explanation over here:</p>

<blockquote>
  <p>The caret will match only at the start of a line. So the regex engine will only attempt to match the remainder of the regex there. The dot and star combination simply matches an entire line, whatever its contents, if any. The parentheses store the matched line into the first backreference.</p>
</blockquote>

<blockquote>
  <p>Next we will match the line separator. I put the question mark into <code>\r?\n</code> to make this regex work with both Windows <code>(\r\n)</code> and UNIX <code>(\n)</code> text files. So up to this point we matched a line and the following line break.</p>
</blockquote>

<blockquote>
  <p>Now we need to check if this combination is followed by a duplicate of that same line. We do this simply with <code>\1</code>. This is the first backreference which holds the line we matched. The backreference will match that very same text.</p>
</blockquote>

<blockquote>
  <p>If the backreference fails to match, the regex match and the backreference are discarded, and the regex engine tries again at the start of the next line. If the backreference succeeds, the plus symbol in the regular expression will try to match additional copies of the line. Finally, the dollar symbol forces the regex engine to check if the text matched by the backreference is a complete line. We already know the text matched by the backreference is preceded by a line break (matched by <code>\r?\n</code>).</p>
</blockquote>

<blockquote>
  <p>Therefore, we now check if it is also followed by a line break or if it is at the end of the file using the dollar sign.</p>
</blockquote>

<blockquote>
  <p>The entire match becomes <code>line\nline</code> (or <code>line\nline\nline</code> etc.). Because we are doing a search and replace, the line, its duplicates, and the line breaks in between them, are all deleted from the file. Since we want to keep the original line, but not the duplicates, we use <code>\1</code> as the replacement text to put the original line back in.</p>
</blockquote>

<p>Hope you found this tip useful!</p>

	</article>
</main>

<script src="/static/vendor/jquery/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
<script src="/static/vendor/hljs/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>